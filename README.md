````markdown
# README.md

## Planning Example Project

This project provides a modular pipeline for generating 2D planning environments, building roadmaps, running search algorithms, and visualizing the results.  
All components are isolated for clarity and reproducibility:

* **C++** handles environment generation, roadmap construction, and path search.
* **Python** orchestrates these modules via `main.py` and visualizes outputs.

---

## 1. Installation

Clone the repository and install Python requirements:

```bash
git clone <this-repo>
cd planning-example

pip install -r requirements.txt
````

> Python is only used for orchestration and visualization.
> All planning modules are written in C++ and built through CMake.

---

## 2. Build Instructions

The project provides a build helper:

```bash
./build.py         # Configure + build (default: Release)
./build.py --debug # Build in Debug mode
./build.py --clean # Remove build directory
```

After building, all binaries appear in:

```text
build/bin/
    ├── build_env
    ├── build_roadmap
    └── build_path        (future)
```

Currently, `build_env` and `build_roadmap` are implemented.

---

## 3. build_env: Role and Specifications

`build_env` is responsible for generating a **random 2D continuous environment** with polygonal obstacles and saving it to:

```text
results/env.txt
```

### Usage

```bash
./build/bin/build_env <num_obstacles> [seed]
```

* `<num_obstacles>` : requested number of obstacles
* `[seed]` (optional) : fixed seed for reproducible environments
* If seed is omitted, a random device generates one
* The actual seed is always written to `env.txt` as a comment header

Python wrapper:

```bash
python main.py --env
python main.py --env --num_obstacles 12 --seed 123
```

---

## Environment Specification (Implemented Constraints)

### World

* Continuous 2D space: **20 × 20**

### Start & Goal

* Start: **(0.5, 0.5)**
* Goal: **(19.5, 19.5)**
* These points **must not lie inside any obstacle**

### Obstacle Count

* Requested M is clamped:

  * **0 ≤ M ≤ 20**

### Obstacle Polygon Properties

Each obstacle is a **simple Jordan curve polygon** with:

* **Vertex count:** 4 to 8 (uniform random)
* **Area:** between **5 and 18** units² (shoelace formula)
* **Sampled uniformly** inside the world boundary
* **No overlap allowed**, ensured by:

  * Edge–edge intersection checks
  * Vertex-in-polygon checks (both directions)

### Output Format (`env.txt`)

```text
# seed <integer>
<M>                # number of generated obstacles
<K1>               # vertices in obstacle 1
x y
x y
...
<K2>
x y
...
<start_x> <start_y>
<goal_x>  <goal_y>
```

This file is later consumed by roadmap and search modules.

---

## 4. build_roadmap: Role and Specifications

`build_roadmap` takes an environment (`env.txt`) and constructs a **roadmap graph** according to a chosen method, writing it to:

```text
results/graph.txt
```

### Usage

```bash
./build/bin/build_roadmap <env_file> <roadmap_type> <out_graph_file>
```

* `<env_file>` : environment file generated by `build_env` (e.g., `results/env.txt`)

* `<roadmap_type>` : one of

  * `prm_random`  – PRM with uniform random sampling
  * `prm_halton`  – PRM with Halton low-discrepancy sampling
  * `prm_sobol`   – PRM with Sobol-like low-discrepancy sampling
  * `visibility`  – visibility graph over obstacle vertices
  * `gvd`         – grid-based skeleton (GVD-like) near obstacles
  * `rrt`         – incremental RRT tree viewed as a roadmap

* `<out_graph_file>` : output graph file (e.g., `results/graph.txt`)

For PRM, GVD, and RRT, the internal RNG is seeded using:

* **Environment seed** (from `env.txt`)
* Plus a hash of `<roadmap_type>`

so the roadmap becomes deterministic for a fixed env + type.

### Output Format (`graph.txt`)

```text
<N>                       # number of nodes
<id0> <x0> <y0>
<id1> <x1> <y1>
...
<M>                       # number of directed edges
<u0> <v0> <w0>            # edge 0: from u0 to v0 with length w0
<u1> <v1> <w1>
...
```

* Node IDs are 0-based integers.
* By convention, node `0` is the start configuration, node `1` is the goal.
* Edges are stored as directed pairs; undirected edges appear as two directed entries.

Python wrapper:

```bash
python main.py --map --roadmap prm_random
python main.py --map --roadmap rrt --num_obstacles 10 --seed 42
```

This runs:

1. `build_env` to create `env.txt`
2. `build_roadmap` with the selected `<roadmap_type>` to create `graph.txt`
3. Visualization (PNG + GIF) if saving is enabled.

---

## 5. Running From Python and Visualization

Environment-only:

```bash
python main.py --env
```

Environment + roadmap:

```bash
python main.py --map --roadmap prm_random
python main.py --map --roadmap rrt --save
```

When visualization and saving are enabled (`--save`), outputs are written under a timestamped folder:

```text
results/re-YYMMDD-HHMM/
    map.png                      # stage 1 (env only)
    map_<roadmap>.{png,gif}      # stage 2 (env + roadmap)
    map_<roadmap>_<search>.{png,gif}   # stage 3 (future: with path)
```

* PNG: final snapshot of the environment + roadmap (+ path at stage 3).
* GIF: simple time-lapse of roadmap construction based on logged node/edge order.
